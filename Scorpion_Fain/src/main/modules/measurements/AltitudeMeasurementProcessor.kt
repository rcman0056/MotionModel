package modules.measurements

import golem.*
import golem.matrix.*
import scorpion.filters.sensor.containers.Measurement
import scorpion.filters.sensor.containers.MeasurementModel
import scorpion.filters.sensor.containers.MeasurementProcessor

/**
 * A measurement processor that accepts altitude updates of a pinson15 block.
 */
open class AltitudeMeasurementProcessor : MeasurementProcessor {

    override var label: String
    override var stateBlockLabels: Array<String>
    /**
     * Constructor to be used in direct instantiations.
     *
     * @param label: The label uniquely identifying this particular processor.
     * @param pinsonLabel: Label of the pinson StateBlock to update. The down
     * error state for the Pinson block must be at index 2 to use this
     * classes generateModel function.
     */
    constructor (label: String, blockLabel: String) {
        this.stateBlockLabels=arrayOf(blockLabel)
        this.label=label
    }

    /**
     * Constructor only to be used by child classes which have multiple
     * StateBlocks to update.
     *
     * @param label: The label uniquely identifying this particular processor.
     * @param blockLabels: An array containing at least the label of the pinson
     * StateBlock to update. The down error state for the Pinson block must be
     * at index 2 to use this classes generateModel function.
     */

    protected constructor (label: String, blockLabels: Array<String>){
        this.stateBlockLabels=blockLabels
        this.label=label
    }


    /**
     * Appends the bias state measurement function to the Pinson
     * state measurement function generated by the super class
     * so both may be updated.
     *
     * @param meas: The differenced measurement from an altimeter, in the same
     * units as the state blocks elements being updated.
     * @param xhat: Current state vector.
     * @param P: Current covariance matrix associated with xhat.
     */
    override fun generateModel(meas: Measurement, xhat: Matrix<Double>,
                               P: Matrix<Double>): MeasurementModel {
        if (meas.measurementData.numRows() != 1)
            throw IllegalArgumentException("Must be a 1x1 measurement")
        var H = fill(1, xhat.numRows()) { row, col -> if (col == 2)
            1.0 else 0.0 }
        return MeasurementModel(meas.measurementData, { H * it },
                H, meas.measurementCov)
        }

    /**
     * Unused for this processor.
     */
    override fun receiveAuxData(auxData: Any) {
        throw UnsupportedOperationException()
    }
}
